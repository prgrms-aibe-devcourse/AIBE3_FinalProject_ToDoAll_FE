name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: ai-review-${{ github.event.pull_request.number || github.event.issue.number }}
  cancel-in-progress: true

env:
  MODEL: gpt-4o-mini
  MAX_TOKENS: "2000"
  MAX_FILES: "30"
  MAX_LINES: "1500"
  EXCLUDE_GLOBS: |
    **/*.lock
    **/node_modules/**
    **/dist/**
    **/*.png
    **/*.jpg
    **/*.svg
    **/*.gif
    **/*.zip
    **/*.map
    **/*.pdf
    **/__snapshots__/**
    **/*.test.tsx
  ONLY_ON_LABEL: ""

jobs:
  review:
    name: Run AI Code Review
    runs-on: ubuntu-latest

    steps:
      - name: Check trigger conditions
        id: gate
        shell: bash
        run: |
          set -euo pipefail
          EVENT="${{ github.event_name }}"
          echo "event=$EVENT" >> "$GITHUB_OUTPUT"

          if [[ "$EVENT" == "issue_comment" ]]; then
            BODY=${{ toJson(github.event.comment.body) }}
            BODY="${BODY%\"}"; BODY="${BODY#\"}"
            if [[ ! "$BODY" =~ ^/ai-review ]]; then
              echo "not_needed=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          if [[ "$EVENT" == "pull_request" && "${{ github.event.pull_request.draft }}" == "true" ]]; then
            echo "not_needed=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          REQ_LABEL="${ONLY_ON_LABEL}"
          if [[ -n "$REQ_LABEL" && "$EVENT" == "pull_request" ]]; then
            HAS_LABEL=$(jq -r --arg L "$REQ_LABEL" '.pull_request.labels[].name | select(.==$L)' <<< '${{ toJson(github.event) }}' || true)
            if [[ -z "$HAS_LABEL" ]]; then
              echo "not_needed=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

      - name: Exit early if not needed
        if: steps.gate.outputs.not_needed == 'true'
        run: echo "AI review not triggered for this event."

      - name: Checkout
        if: steps.gate.outputs.not_needed != 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup SHAs
        id: shas
        if: steps.gate.outputs.not_needed != 'true'
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE="${{ github.event.pull_request.base.sha }}"
            HEAD="${{ github.event.pull_request.head.sha }}"
            PR_NUMBER="${{ github.event.pull_request.number }}"
          else
            PR_NUMBER="${{ github.event.issue.number }}"
            BASE=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER --jq .base.sha)
            HEAD=$(gh api repos/${{ github.repository }}/pulls/$PR_NUMBER --jq .head.sha)
          fi
          echo "base=$BASE" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD" >> "$GITHUB_OUTPUT"
          echo "pr=$PR_NUMBER" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Filter files
        id: files
        if: steps.gate.outputs.not_needed != 'true'
        shell: bash
        run: |
          BASE="${{ steps.shas.outputs.base }}"
          HEAD="${{ steps.shas.outputs.head }}"
          mapfile -t ALL_FILES < <(git diff --name-only "$BASE" "$HEAD")
          FILTERED=()
          while IFS= read -r G; do
            EXCLUDES+=("$G")
          done < <(printf "%s\n" "${EXCLUDE_GLOBS}")
          for f in "${ALL_FILES[@]}"; do
            SKIP=0
            for g in "${EXCLUDES[@]}"; do
              [[ $f == $g || $f == */$g ]] && SKIP=1 && break
            done
            (( SKIP == 0 )) && FILTERED+=("$f")
          done
          COUNT=${#FILTERED[@]}
          (( COUNT > ${MAX_FILES} )) && FILTERED=("${FILTERED[@]:0:${MAX_FILES}}")
          printf "%s\n" "${FILTERED[@]}" > files.txt
          echo "list=$(jq -R -s -c 'split(\"\\n\")[:-1]' < files.txt)" >> "$GITHUB_OUTPUT"

      - name: Create patch
        id: diff
        if: steps.gate.outputs.not_needed != 'true'
        shell: bash
        run: |
          BASE="${{ steps.shas.outputs.base }}"
          HEAD="${{ steps.shas.outputs.head }}"
          LINES=$(git diff --unified=0 "$BASE" "$HEAD" | grep -E '^(\+|\-)' | wc -l | tr -d ' ')
          if (( LINES > ${MAX_LINES} )); then
            jq -n --argjson files '${{ steps.files.outputs.list }}' '{oversize:true, files:$files}' > diff.json
            echo "oversize=true" >> "$GITHUB_OUTPUT"
          else
            git diff "$BASE" "$HEAD" > diff.patch
            [[ $(wc -c < diff.patch) -gt 200000 ]] && head -c 200000 diff.patch > diff.patch.trim && mv diff.patch.trim diff.patch
            jq -n --rawfile patch diff.patch --arg base "$BASE" --arg head "$HEAD" '{oversize:false, base:$base, head:$head, patch:$patch}' > diff.json
            echo "oversize=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Compose prompts
        id: prompt
        shell: bash
        run: |
          PR=${{ steps.shas.outputs.pr }}
          TITLE=$(gh api repos/${{ github.repository }}/pulls/$PR --jq .title)
          BODY=$(gh api repos/${{ github.repository }}/pulls/$PR --jq .body)
          AUTHOR=$(gh api repos/${{ github.repository }}/pulls/$PR --jq .user.login)
          LABELS=$(gh api repos/${{ github.repository }}/pulls/$PR --jq '[.labels[].name] | join(", ")')

          cat > system.txt <<EOF
You are a senior frontend reviewer for React + TypeScript projects.
You provide actionable, concise code reviews with file/line hints.
Focus on: component structure, state management, hooks misuse, render performance, type safety, accessibility, styling consistency (Tailwind), test coverage, and clean code.
EOF

          cat > user.txt <<EOF
<PR_META>
title: $TITLE
author: $AUTHOR
labels: $LABELS
body: |
$BODY
</PR_META>

<REVIEW_SCOPE>
- Only review the provided diff/patch.
- Do NOT request full repo context.
</REVIEW_SCOPE>

<TECH_STACK_HINTS>
- React 18+, TypeScript, Vite, Tailwind CSS, Zustand/Redux, React Query, React Router.
</TECH_STACK_HINTS>

<OUTPUT_FORMAT>
- 1-3 risk bullets
- Then issue list with file hints & fixes
- Include test ideas if possible
</OUTPUT_FORMAT>

<DIFF_JSON>
$(cat diff.json | jq -c .)
</DIFF_JSON>
EOF

      - name: Call OpenAI
        id: llm
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          [[ -z "${OPENAI_API_KEY:-}" ]] && echo "::error::Missing OPENAI_API_KEY" && exit 1

          RESP=$(jq -n \
            --arg model "$MODEL" \
            --arg sys "$(cat system.txt)" \
            --arg usr "$(cat user.txt)" \
            --argjson max_tokens ${MAX_TOKENS} \
            '{
              model: $model,
              temperature: 0.2,
              max_tokens: $max_tokens,
              messages: [
                {role:"system", content:$sys},
                {role:"user", content:$usr}
              ]
            }' | curl -sS https://api.openai.com/v1/chat/completions \
                -H "Authorization: Bearer $OPENAI_API_KEY" \
                -H "Content-Type: application/json" \
                -d @-)

          CONTENT=$(jq -r '.choices[0].message.content' <<< "$RESP")
          CONTENT=${CONTENT:-":robot: No feedback generated."}
          echo "content<<EOF" >> "$GITHUB_OUTPUT"
          echo "$CONTENT" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Post PR comment
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PR=${{ steps.shas.outputs.pr }}
          BODY=${{ steps.llm.outputs.content }}
          COMMENT="### ðŸ¤– AI Code Review (model: ${MODEL})\n<details><summary>ê²°ê³¼ ë³´ê¸°</summary>\n\n$BODY\n\n</details>"
          gh api repos/${{ github.repository }}/issues/$PR/comments -f body="$COMMENT"
